# [Link to video.](https://www.youtube.com/watch?v=BKl9aOCuJus&list=PLVD25niNi0Bkf1S2xcJ3NaMINjkkfTXxF)

### Finite Data Representation

Finite data representation refers to the limitations of using a finite amount of space to store data and perform calculations.

### Integer Overflow and Underflow

All computers use a fixed number of bits to represent data. This means that there are limits as to what integers a program can use.  

```java
int x = 1000000000000; // doesn't work
```

Java uses 32-bit data representation for integers: The lowest integer it can store is –2<sup>31</sup> and the highest integer it can store is 2<sup>31</sup> – 1. We can use `Integer.MAX_VALUE` and `Integer.MIN_VALUE` to obtain these values.

When we try to compute a value beyond this domain, it is called **integer overflow** (beyond `Integer.MAX_VALUE`) or **integer underflow** (beyond `Integer.MIN_VALUE`).

> Fun fact: The Ariane 5 rocket launch in 1996 failed due to an integer overflow error. The rocket self-destructed and the damage cost approximately $370 million USD.
>
> Here is a video of the Ariane 5 Rocket launch: https://www.youtube.com/watch?v=i67ycNPceHc.
>
> You can hear about the technical explanation from 1:02:25-1:05:32 in this talk: https://www.youtube.com/watch?v=6JwEYamjXpA#t=1h2m25s.

If we try to add, subtract, or multiply integers to get a result that is outside of that range, the result will seem nonsensical.

```java
System.out.println(2000000000 * 2); // prints -294967296
System.out.println(-2000000000 * 2); // prints 294967296
```

Why did we get these results? It's because as soon as the result of a calculation exceeds `Integer.MAX_VALUE`, it becomes `Integer.MIN_VALUE` and the calculation continues. Similarly, as soon as the result exceeds `Integer.MIN_VALUE`, it becomes `Integer.MAX_VALUE` and the calculation continues.

```java
System.out.println(Integer.MAX_VALUE + 1); // prints -2147483648, which is Integer.MIN_VALUE
System.out.println(Integer.MIN_VALUE - 1); // prints 2147483647, which is Integer.MAX_VALUE
```

### Long Integers

If we're dealing with numbers in the billions and we don't want to worry about integer overflow and underflow, we can use `long` instead of `int`. Long integers go from `Long.MIN_VALUE` (-2<sup>63</sup>, around 9 quintillion) up to `Long.MAX_VALUE` (2<sup>63</sup>–1). 

2<sup>31</sup> is approximately 2 billion whereas 2<sup>63</sup> is approximately 9 quintillion, or 9 billion billion. 

### Literals

If we write out some digits, Java will automatically treat it as an **integer literal** (it's *literally* a bunch of digits forming an integer). To make it a **long long literal**, we can append an `L`.

```java
long n = 3000000000L; // 3 billion (higher than Integer.MAX_VALUE)

System.out.println(2000000000L * 2); // prints 4000000000
System.out.println(-2000000000L * 2); // prints -4000000000
```

Now we only have to deal with overflow and underflow if we're working with numbers in the quintillions.

```java
System.out.println(5000000000000000000L * 2); // prints -8446744073709551616
System.out.println(-5000000000000000000L * 2); // prints 8446744073709551616
```

### Imprecision of Double and Float

Programming languages tend to be poor at accurately dividing long decimal numbers due to finite data representation. Be aware that if a calculation in any of your programs seems to be off, it might be that your algorithm may be fine and Java simply can't perform the calculation accurately. 

If precision is important in your program, we can use data types that take up more space (and are thus more precise), such as `BigInteger` and `BigDecimal`.
