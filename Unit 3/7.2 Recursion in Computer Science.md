# [Link to video.]

### Recursion

In computer science, a **recursive function** is a function that calls itself within the body of the function. The base cases determine when the method stops running.

> For fun:
> 
> Search the word *recursion* on Google. What happens?
> 
> [See image](../Images/Recursion.png).

### Factorials!

Recall that the full definition of *n!* is  *n! = n × (n-1) × ... × 1, 0! = 1! = 1*, *n ∈ ℕ*. 

We could write a method to calculate *n!* using a loop like this:

```java
/**
 * Takes an integer n and calculates the value of n!
 *
 * @param n a non-negative integer
 * @return n!
 */
public static int factorial(int n) {
    int answer = 1;

    while (n > 0) {
        answer *= n;
        n--;
    }

    return answer;
}
```

Or, we could write it using recursion like this:

```java
/**
 * Takes an integer n and calculates the value of n!
 *
 * @param n a non-negative integer
 * @return n!
 */
public static int factorial(int n) {
    if (n == 0 || n == 1) return 1;
    else return n * factorial(n - 1); // this uses the identity n! = n*(n-1)!
}
```

### Fibonacci Sequence

Recall that the definition of the Fibonacci sequence is *f(n) = f(n-1) + f(n-2), f(1) = f(2) = 1*, *n ∈ ℕ*. 

We could write a method to calculate the n<sup>th</sup> Fibonacci number using a loop like this:

```java
/**
 * Takes a positive integer n and returns the nth number in the Fibonacci sequence.
 *
 * @param n a positive integer
 * @return the nth Fibonacci number; if n isn't a positive integer, it returns -1
 */
public static int fibonacci(int n) {
    if (n == 1 || n == 2) return 1;

    int previous1 = 1; // the n-1th term
    int previous2 = 1; // the n-2th term

    for (int i = 3; i < n; i++) {
        previous1 += previous2;
        previous2 = previous1 - previous2;
    }

    return previous1 + previous2;
}
```

Or, we could write it using recursion like this:

```java
/**
 * Takes a positive integer n and returns the nth number in the Fibonacci sequence.
 *
 * @param n a positive integer
 * @return the nth Fibonacci number; if n isn't a positive integer, it returns -1
 */
public static int fibonacci(int n) {
    if (n == 1 || n == 2) return 1;
    else return fibonacci(n - 1) + fibonacci(n - 2);
}
```

How does this work? Let's **trace** `fibonacci(4)` to see what happens. The => symbol is used to indicate what happens next.

`fibonacci(4)`    
=> `fibonacci(3) + fibonacci(2)`    
=> `fibonacci(2) + fibonacci(1) + fibonacci(2)`    
=> `1 + 1 + 1`    
=> `3`

Let's try again with `fibonacci(6)`.

`fibonacci(6)`    
=> `fibonacci(5) + fibonacci(4)`    
=> `fibonacci(4) + fibonacci(3) + fibonacci(4)`   
=> `fibonacci(3) + fibonacci(2) + fibonacci(3) + fibonacci(4)`   
=> `fibonacci(2) + fibonacci(1) + fibonacci(2) + fibonacci(3) + fibonacci(4)`    
=> `1 + 1 + 1 + fibonacci(3) + fibonacci(4)`   
=> `3 + fibonacci(3) + fibonacci(4)`   
=> `3 + fibonacci(2) + fibonacci(1) + fibonacci(4)`   
=> `3 + 1 + 1 + fibonacci(4)`   
=> `5 + fibonacci(4)`   
=> `5 + fibonacci(3) + fibonacci(2)`   
=> `5 + fibonacci(2) + fibonacci(1) + fibonacci(2)`   
=> `5 + 1 + 1 + 1`   
=> `8`   

### Issues with Recursion

**Issue 1.** Recursion can be used to create efficient programs, but it can also be used to create inefficient programs. In the case of Fibonacci numbers, the number of recursive calls grows exponentially as the Fibonacci number increases. If we want a more efficient implementation of Fibonacci numbers, we could use an iterative approach that involves counting forwards instead of backwards.

**Issue 2.** There is also the issue of infinite recursion. Similar to infinite loops, an infinite recursion never terminates. This often occurs when some of the base cases are missing or incorrect.

**Issue 3.** Sometimes, recursive functions can be rewritten in closed form (i.e. an expression that doesn't involve recursion). For example, this table of values can be expressed in closed form as *f(n) = 2n + 1, n ∈ ℕ* or recursively as *f(1) = 3*, *f(n) = f(n-1) + 2*, *n > 1*. 

| n   | f(n)   |
| --- | ---    |
| 1   | 3      |
| 2   | 5      |
| 3   | 7      |
| 4   | 9      |
| 5   | 11     |
| ⋮   | ⋮      |
| n   | 2n + 1 |


When closed form is possible, it is more efficient to implement it without recursion.
