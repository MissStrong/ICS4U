# [Link to Video]

### Fibonacci with Recursion

Recall the recursive implementation of the Fibonacci sequence: 1, 1, 3, 5, 8, 13, 21, 34, 55, ...

```java
/**
 * Takes a positive integer n and returns the nth number in the Fibonacci sequence.
 *
 * @param n a positive integer
 * @return the nth Fibonacci number
 */
public static int fibonacci(int n) {
    if (n == 1 || n == 2) return 1;
    else return fibonacci(n - 1) + fibonacci(n - 2);
}
```

One of the issues with recursion is that it slow due to the large number of function calls. One of the ways we can reeduce the number of function calls needed using **dynamic programming**.

### Dynamic Programming

Dynamic programming (DP) involves storing previously calculated answers to avoid redoing the same calculation more than one. There are two approaches to DP: **Memoization** and **Tabulation**. Memoization is used alongside recursion, whereas tabulation is used alongside iteraiton.

### Memoization

Memoization (not memorization!) involves storing ("memo-ing") previously stored recursive calls in a recursive function.

```java
  private static HashMap<Integer, Integer> memo = new HashMap();

  /**
   * Takes a positive integer n and returns the nth number in the Fibonacci sequence.
   *
   * @param n a positive integer
   * @return the nth Fibonacci number
   */
  public static int fibonacci(int n) { 
      if (n == 1 || n == 2) return 1;
      if (memo.containsKey(n)) return memo.get(n); // if we have the answer, retrieve it
      
      memo.put(n, fibonacci(n - 1) + fibonacci(n - 2)); // otherwise store the calculation
      return fibonacci(n - 1) + fibonacci(n - 2);
  }
```

The HashMap `memo` stores the previously calculated answers: `{3=2, 4=3, 5=5}`. This ensures that the program does not perform the same recursive call more than once. 

### Fibonacci with Recursion

Here is one way to calculate Fibonacci with a loop instead of recursion.

```java
/**
 * Takes a positive integer n and returns the nth number in the Fibonacci sequence.
 *
 * @param n a positive integer
 * @return the nth Fibonacci number; if n isn't a positive integer, it returns -1
 */
public static int fibonacci(int n) {
    if (n == 1 || n == 2) return 1;

    int previous1 = 1; // the n-1th term
    int previous2 = 1; // the n-2th term

    for (int i = 3; i < n; i++) {
        previous1 += previous2;
        previous2 = previous1 - previous2;
    }

    return previous1 + previous2;
}
```

We can use dynamic programming to store answers using tabulation.

### Tabulation

Tabulation involves storing answers starting from the base case and building upwards. This allows us to make multiple function efficiently.

```java
  private static HashMap<Integer, Integer> memo = new HashMap(Map.of(1, 1, 2, 1);

  /**
   * Takes a positive integer n and returns the nth number in the Fibonacci sequence.
   *
   * @param n a positive integer
   * @return the nth Fibonacci number
   */
  public static int fibonacci(int n) { 
        for (int i = 3; i <= n; i++) {
            if (!memo.containsKey(i)) {
                table.put(i, table.get(i - 1) + table.get(i - 2));
            }
        }

        return table.get(n);
  }
```
